# AutoMem Memory Rules for CLAUDE.md

Add this section to your `~/.claude/CLAUDE.md` file. The SessionStart hook will prompt memory recall automatically.

## Quick Installation

```bash
cat templates/CLAUDE_MD_MEMORY_RULES.md >> ~/.claude/CLAUDE.md
```

## Memory Rules Template

Add this to `~/.claude/CLAUDE.md`:

````markdown
<memory_rules>
MEMORY MCP USAGE - AUTOMEM INTEGRATION

TOOL NAMING (IMPORTANT):
- MCP servers expose tools like `recall_memory`, `store_memory`, etc.
- Claude Code/Claude Desktop typically expose them as `mcp__<server>__<tool>`.
- These examples assume your server name is `memory` (so `mcp__memory__*`).
- If your tools are prefixed differently (common in plugin installs), use the exact names shown in your tool list.

SESSION INITIALIZATION:
Use **two-phase recall** at session start - preferences and task context need different strategies:

**Phase 1: Preferences (tag-only, NO time limit)**

- mcp__memory__recall_memory({ tags: ["preference"], limit: 10 })
- Key: No time_query - preferences don't expire. Tag-only queries return cleaner results.

**Phase 2: Task context (semantic + project-specific)**

- mcp__memory__recall_memory({ queries: ["<task topic>", "user corrections", "[project] patterns"], tags: ["[project]"], limit: 10, time_query: "last 30 days" })

**For debugging:** mcp__memory__recall_memory({ query: "[error symptom]", tags: ["bugfix", "solution"], limit: 10 })

**Key insight:** Don't mix tag-based preference recall with semantic task recall - combining them dilutes results.

MCP TOOLS AVAILABLE:

- store_memory: Save with content, tags, importance (0.0-1.0), type, metadata
- recall_memory: Hybrid search (semantic + keyword + tags + time filters)
- associate_memories: Create relationships (11 types including LEADS_TO, REINFORCES, CONTRADICTS)
- update_memory: Modify existing memories without duplication
- delete_memory: Remove memories by ID
- check_database_health: Monitor AutoMem service status

MEMORY SCHEMA:

- importance: 0.9-1.0 (critical), 0.7-0.8 (important), 0.5-0.6 (standard), <0.5 (minor)
- type: Decision|Pattern|Preference|Style|Habit|Insight|Context
- tags: Array for categorization and filtering
- embedding: 768-dim vector (auto-generated by AutoMem if OPENAI_API_KEY set)

CONTENT SIZE GUIDELINES:

- Target: 150-300 characters (one meaningful paragraph)
- Maximum: 500 characters (auto-summarized if exceeded)
- Hard limit: 2000 characters (rejected)
- Format: "Brief title. Context and details. Impact/outcome."
- If more detail needed: split into multiple memories, use metadata for structured data

STORAGE PATTERNS (opt-in, use when appropriate):

User preferences (importance: 0.9):
mcp__memory__store_memory({
content: "User preference: [exact quote]",
type: "Preference", // ALWAYS provide type
confidence: 0.95,
tags: ["preference", "workflow"],
importance: 0.9
})

Architectural decisions (importance: 0.9):
mcp__memory__store_memory({
content: "Decided [choice] because [rationale]",
type: "Decision",
confidence: 0.95,
tags: ["decision", "architecture", "project-name"],
importance: 0.9
})

Bug fixes (importance: 0.7):
mcp__memory__store_memory({
content: "Fixed [issue] in [project]: [solution] Root cause: [analysis]",
type: "Insight",
confidence: 0.95,
tags: ["bugfix", "project-name", "solution"],
importance: 0.7
})

Feature implementations (importance: 0.8):
mcp__memory__store_memory({
content: "Implemented [feature] using [approach]",
type: "Pattern",
confidence: 0.95,
tags: ["feature", "project-name", "pattern"],
importance: 0.8
})

RECALL PATTERNS:

**Preferences (tag-only, no time limit):**
mcp__memory__recall_memory({
tags: ["preference"],
limit: 10
// NO time_query - preferences don't expire
})

**Task context (semantic + time-limited):**
mcp__memory__recall_memory({
queries: ["<topic 1>", "<topic 2>", "user corrections"],
tags: ["<project>"],
limit: 10,
auto_decompose: true,
time_query: "last 30 days"
})

**Debugging (error-focused):**
mcp__memory__recall_memory({
query: "[error message or symptom]",
tags: ["bugfix", "solution"],
limit: 10
})

**Strict tag filtering:**
mcp__memory__recall_memory({
tags: ["pattern", "react", "hooks"],
tag_mode: "all", // requires ALL tags (default is "any")
limit: 20
})

**Key insight:** Tag-based recall for stable knowledge (preferences, conventions). Semantic recall for dynamic context (current task, recent work). Don't mix them in one query.

RELATIONSHIP TYPES:
| Type | Use Case |
|------|----------|
| LEADS_TO | Bug → Solution, Problem → Fix |
| REINFORCES | Supporting evidence, Validation |
| CONTRADICTS | Conflicting approaches, Alternatives |
| EVOLVED_INTO | Knowledge progression, Iterations |
| INVALIDATED_BY | Outdated info → Current approach |
| DERIVED_FROM | Source relationships, Origins |
| RELATES_TO | General connections |
| PREFERS_OVER | User/team preferences |
| EXEMPLIFIES | Pattern examples |
| OCCURRED_BEFORE | Temporal sequence |
| PART_OF | Hierarchical structure |

LIFECYCLE MANAGEMENT:

Update evolving knowledge:
mcp__memory__update_memory({
memory_id: "id",
content: "Updated: [new insight]",
importance: 0.9
})

Deprecate outdated info:
mcp__memory__update_memory({
memory_id: "old_id",
importance: 0.1,
metadata: { deprecated: true }
})
// Then: mcp__memory__associate_memories({ memory1_id: old_id, memory2_id: new_id, type: "INVALIDATED_BY", strength: 0.9 })

Delete duplicates:
// First check: mcp__memory__recall_memory({ query: "[keywords]", limit: 5 })
// If found: mcp__memory__delete_memory({ memory_id })

ASSOCIATION TRIGGERS:

After storing, create associations for these memory types:

| Memory Type     | Trigger                                  | Association Type |
| --------------- | ---------------------------------------- | ---------------- |
| User correction | Always search for what's being corrected | INVALIDATED_BY   |
| Bug fix         | Link to original bug discovery           | DERIVED_FROM     |
| Decision        | Link to alternatives considered          | PREFERS_OVER     |
| Evolution       | When knowledge supersedes old            | EVOLVED_INTO     |

Example (user correction):

```javascript
// After storing correction, find and link related memories
const related = mcp__memory__recall_memory({ query: "[topic]", limit: 5 });
if (!related?.length) {
  // Skip association if nothing relevant was recalled
  return;
}
mcp__memory__associate_memories({
  memory1_id: related[0].id, // Old memory
  memory2_id: newMemoryId, // New correction
  type: "INVALIDATED_BY",
  strength: 0.9,
});
```
````

NEVER STORE:

- Temporary file contents or debug output
- Sensitive credentials or keys
- Large code blocks (store patterns/decisions instead)
- Duplicate memories (check first with recall)
- Wall-of-text memories (split into atomic pieces)

BEST PRACTICES:

- Tag consistently for better recall (project-name, language, domain)
- Use importance scores to prioritize: user preferences (0.9), features (0.8), bugs (0.7)
- Create relationships between related memories for graph navigation
- Update rather than duplicate when knowledge evolves
- Let low-importance memories (<0.3) decay naturally
  </memory_rules>

```

```
