# AutoMem Memory Rules for CLAUDE.md

Add this section to your `~/.claude/CLAUDE.md` file. The SessionStart hook will prompt memory recall automatically.

## Quick Installation

```bash
cat templates/CLAUDE_MD_MEMORY_RULES.md >> ~/.claude/CLAUDE.md
```

## Memory Rules Template

Add this to `~/.claude/CLAUDE.md`:

```markdown
<memory_rules>
MEMORY MCP USAGE - AUTOMEM INTEGRATION

SESSION INITIALIZATION:
At session start, recall relevant context:

- mcp**memory**recall_memory({ query: "project: [name]", limit: 10 })
- mcp**memory**recall_memory({ tags: ["preference", "workflow"], limit: 10 })
- For debugging: mcp**memory**recall_memory({ query: "[project] error", tags: ["solution"], time_query: "last 24 hours" })

MCP TOOLS AVAILABLE:

- store_memory: Save with content, tags, importance (0.0-1.0), type, metadata
- recall_memory: Hybrid search (semantic + keyword + tags + time filters)
- associate_memories: Create relationships (11 types including LEADS_TO, REINFORCES, CONTRADICTS)
- update_memory: Modify existing memories without duplication
- delete_memory: Remove memories by ID
- check_database_health: Monitor AutoMem service status

MEMORY SCHEMA:

- importance: 0.9-1.0 (critical), 0.7-0.8 (important), 0.5-0.6 (standard), <0.5 (minor)
- type: Decision|Pattern|Preference|Style|Habit|Insight|Context
- tags: Array for categorization and filtering
- embedding: 768-dim vector (auto-generated by AutoMem if OPENAI_API_KEY set)

CONTENT SIZE GUIDELINES:

- Target: 150-300 characters (one meaningful paragraph)
- Maximum: 500 characters (auto-summarized if exceeded)
- Hard limit: 2000 characters (rejected)
- Format: "Brief title. Context and details. Impact/outcome."
- If more detail needed: split into multiple memories, use metadata for structured data

STORAGE PATTERNS (opt-in, use when appropriate):

User preferences (importance: 0.9):
mcp**memory**store_memory({
content: "User preference: [exact quote]",
type: "Preference",  // ALWAYS provide type
confidence: 0.95,
tags: ["preference", "workflow"],
importance: 0.9
})

Architectural decisions (importance: 0.9):
mcp**memory**store_memory({
content: "Decided [choice] because [rationale]",
type: "Decision",
confidence: 0.95,
tags: ["decision", "architecture", "project-name"],
importance: 0.9
})

Bug fixes (importance: 0.7):
mcp**memory**store_memory({
content: "Fixed [issue] in [project]: [solution] Root cause: [analysis]",
type: "Insight",
confidence: 0.95,
tags: ["bugfix", "project-name", "solution"],
importance: 0.7
})

Feature implementations (importance: 0.8):
mcp**memory**store_memory({
content: "Implemented [feature] using [approach]",
type: "Pattern",
confidence: 0.95,
tags: ["feature", "project-name", "pattern"],
importance: 0.8
})

RECALL PATTERNS:

Hybrid search (semantic + keyword):
mcp**memory**recall_memory({
query: "[search terms]",
tags: ["relevant", "tags"],
limit: 15,
time_query: "last 30 days"
})

Tag-based filtering:
mcp**memory**recall_memory({
tags: ["pattern", "react", "hooks"],
tag_mode: "all", // or "any" (default)
limit: 20
})

Time-constrained search:
mcp**memory**recall_memory({
query: "[topic]",
time_query: "today" | "last week" | "last 7 days"
})

RELATIONSHIP TYPES:
| Type | Use Case |
|------|----------|
| LEADS_TO | Bug → Solution, Problem → Fix |
| REINFORCES | Supporting evidence, Validation |
| CONTRADICTS | Conflicting approaches, Alternatives |
| EVOLVED_INTO | Knowledge progression, Iterations |
| INVALIDATED_BY | Outdated info → Current approach |
| DERIVED_FROM | Source relationships, Origins |
| RELATES_TO | General connections |
| PREFERS_OVER | User/team preferences |
| EXEMPLIFIES | Pattern examples |
| OCCURRED_BEFORE | Temporal sequence |
| PART_OF | Hierarchical structure |

LIFECYCLE MANAGEMENT:

Update evolving knowledge:
mcp**memory**update_memory({
memory_id: "id",
content: "Updated: [new insight]",
importance: 0.9
})

Deprecate outdated info:
mcp**memory**update_memory({
memory_id: "old_id",
importance: 0.1,
metadata: { deprecated: true }
})
// Then: associate_memories(old_id, new_id, type="INVALIDATED_BY")

Delete duplicates:
// First check: recall_memory({ query: "[keywords]", limit: 5 })
// If found: delete_memory(memory_id)

ASSOCIATION TRIGGERS:

After storing, create associations for these memory types:
| Memory Type | Trigger | Association Type |
|-------------|---------|------------------|
| User correction | Always search for what's being corrected | INVALIDATED_BY |
| Bug fix | Link to original bug discovery | DERIVED_FROM |
| Decision | Link to alternatives considered | PREFERS_OVER |
| Evolution | When knowledge supersedes old | EVOLVED_INTO |

Example (user correction):
// After storing correction, find and link related memories
const related = mcp**memory**recall_memory({ query: "[topic]", limit: 5 })
mcp**memory**associate_memories({
  memory1_id: related[0].id,    // Old memory
  memory2_id: newMemoryId,      // New correction
  type: "INVALIDATED_BY",
  strength: 0.9
})

NEVER STORE:

- Temporary file contents or debug output
- Sensitive credentials or keys
- Large code blocks (store patterns/decisions instead)
- Duplicate memories (check first with recall)
- Wall-of-text memories (split into atomic pieces)

BEST PRACTICES:

- Tag consistently for better recall (project-name, language, domain)
- Use importance scores to prioritize: user preferences (0.9), features (0.8), bugs (0.7)
- Create relationships between related memories for graph navigation
- Update rather than duplicate when knowledge evolves
- Let low-importance memories (<0.3) decay naturally
  </memory_rules>
```
