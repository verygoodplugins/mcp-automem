# AutoMem Memory Rules for CLAUDE.md

This template provides AI instructions for automatic memory management with AutoMem. Add this section to your `~/.claude/CLAUDE.md` file to enable intelligent memory storage and recall.

> **For complete integration details**, see [CLAUDE_CODE_INTEGRATION.md](CLAUDE_CODE_INTEGRATION.md) which explains:
> - How the hook system works
> - What files get modified during installation
> - The memory queue and processing pipeline
> - Expected behavior and troubleshooting

> ⚠️ **IMPORTANT:** The default installation is intentionally minimal and quiet (git commits + builds only). Automatic capture hooks beyond these are OPTIONAL and should be enabled only if you explicitly want them. This is an experimental feature actively evolving based on real-world usage. The philosophy is opt-in, not opt-out. Avoid auto-storing content unless the signal is clearly high.

## Quick Installation

```bash
cat templates/CLAUDE_MD_MEMORY_RULES.md >> ~/.claude/CLAUDE.md
```

Or manually copy the `<thinking_mode>` and `<memory_rules>` sections below to `~/.claude/CLAUDE.md`

## Memory Rules Template

Add this to your `~/.claude/CLAUDE.md` file:

```markdown
<!-- automem-claude-version: 0.9.0 -->
<memory_rules>
MEMORY MCP USAGE - AUTOMEM INTEGRATION

SESSION INITIALIZATION:
At session start, recall relevant context:
- mcp__memory__recall_memory({ query: "project: [name]", limit: 20, time_query: "last 7 days" })
- mcp__memory__recall_memory({ tags: ["preference", "workflow"], limit: 30 })
- For debugging: recall_memory({ query: "[project] error", tags: ["solution"], time_query: "last 24 hours" })

MCP TOOLS AVAILABLE:
- store_memory: Save with content, type, confidence, tags, importance (0.0-1.0), metadata
- recall_memory: Hybrid search with graph expansion and context awareness
  - Basic: query, queries (multi-query), tags, limit, time_query
  - Graph: expand_entities (multi-hop), expand_relations (follow edges), auto_decompose
  - Expansion filters: expand_min_importance (0-1), expand_min_strength (0-1) to reduce noise
  - Context: language, active_path, context, context_tags, context_types, priority_ids
- associate_memories: Create relationships (11 types including LEADS_TO, REINFORCES, CONTRADICTS)
- update_memory: Modify existing memories without duplication
- delete_memory: Remove memories by ID
- check_database_health: Monitor AutoMem service status

MEMORY SCHEMA:
- content: Memory text (no [TYPE] prefix needed)
- type: Decision|Pattern|Preference|Style|Habit|Insight|Context (optional, auto-classified if omitted)
- confidence: 0.0-1.0 (default: 0.9 if type provided, auto-computed otherwise)
- importance: 0.9-1.0 (critical), 0.7-0.8 (important), 0.5-0.6 (standard), <0.5 (minor)
- tags: Array for categorization and filtering
- embedding: 768-dim vector (auto-generated by AutoMem if OPENAI_API_KEY set)

STORAGE PATTERNS (opt-in, use when appropriate):

User preferences (importance: 0.9):
  mcp__memory__store_memory({
    content: "User preference: [exact quote]",
    type: "Preference",
    confidence: 0.95,
    tags: ["preference", "workflow"],
    importance: 0.9
  })

Architectural decisions (importance: 0.9):
  mcp__memory__store_memory({
    content: "Decided [choice] because [rationale]",
    type: "Decision",
    confidence: 0.95,
    tags: ["architecture", "project-name"],
    importance: 0.9
  })

Bug fixes (importance: 0.7-0.8):
  mcp__memory__store_memory({
    content: "Fixed [issue] in [project]: [solution]. Root cause: [analysis]",
    type: "Insight",
    confidence: 0.9,
    tags: ["bugfix", "project-name", "solution"],
    importance: 0.8
  })

Feature implementations (importance: 0.7-0.8):
  mcp__memory__store_memory({
    content: "Implemented [feature] using [approach]. Impact: [outcome]",
    type: "Pattern",
    confidence: 0.9,
    tags: ["feature", "project-name", "pattern"],
    importance: 0.7
  })

RECALL PATTERNS:

Hybrid search (semantic + keyword):
  mcp__memory__recall_memory({
    query: "[search terms]",
    tags: ["relevant", "tags"],
    limit: 15,
    time_query: "last 30 days"
  })

Multi-query recall (broader coverage):
  mcp__memory__recall_memory({
    queries: ["auth patterns", "login flow", "JWT"],  // Server deduplicates
    limit: 15
  })

Tag-based filtering:
  mcp__memory__recall_memory({
    tags: ["pattern", "react", "hooks"],
    tag_mode: "all",  // or "any" (default)
    limit: 20
  })

Time-constrained search:
  mcp__memory__recall_memory({
    query: "[topic]",
    time_query: "today" | "last week" | "last 7 days"
  })

Multi-hop reasoning (entity expansion):
  // For questions like "What is Sarah's sister's job?"
  // Finds "Sarah's sister is Rachel" → expands to memories about Rachel
  mcp__memory__recall_memory({
    query: "What is Sarah's sister's job?",
    expand_entities: true
  })

Graph expansion (follow relationships):
  mcp__memory__recall_memory({
    query: "architecture decisions",
    expand_relations: true,  // Follow RELATES_TO, LEADS_TO, etc.
    relation_limit: 5,
    expand_min_importance: 0.5,  // Only expand to important memories
    expand_min_strength: 0.3     // Only follow strong associations
  })

Context-aware recall (for coding):
  mcp__memory__recall_memory({
    query: "error handling",
    language: "python",           // Prioritize Python memories
    context: "coding-style",
    context_types: ["Style", "Pattern"],  // Boost these types
    context_tags: ["best-practice"]
  })

Auto query decomposition:
  mcp__memory__recall_memory({
    query: "React OAuth authentication patterns",
    auto_decompose: true  // Splits into sub-queries automatically
  })

RELATIONSHIP TYPES:
| Type | Use Case |
|------|----------|
| LEADS_TO | Bug → Solution, Problem → Fix |
| REINFORCES | Supporting evidence, Validation |
| CONTRADICTS | Conflicting approaches, Alternatives |
| EVOLVED_INTO | Knowledge progression, Iterations |
| INVALIDATED_BY | Outdated info → Current approach |
| DERIVED_FROM | Source relationships, Origins |
| RELATES_TO | General connections |
| PREFERS_OVER | User/team preferences |
| EXEMPLIFIES | Pattern examples |
| OCCURRED_BEFORE | Temporal sequence |
| PART_OF | Hierarchical structure |

LIFECYCLE MANAGEMENT:

Update evolving knowledge:
  mcp__memory__update_memory({
    memory_id: "id",
    content: "Updated: [new insight]",
    type: "Insight",
    confidence: 0.95,
    importance: 0.9
  })

Deprecate outdated info:
  mcp__memory__update_memory({
    memory_id: "old_id",
    importance: 0.1,
    metadata: { deprecated: true }
  })
  // Then: associate_memories(old_id, new_id, type="INVALIDATED_BY")

Delete duplicates:
  // First check: recall_memory({ query: "[keywords]", limit: 5 })
  // If found: delete_memory(memory_id)

NEVER STORE:
- Temporary file contents or debug output
- Sensitive credentials or keys
- Large code blocks (store patterns/decisions instead)
- Duplicate memories (check first with recall)
- Type prefixes in content ([DECISION], [BUG-FIX], etc. - use type field instead)

BEST PRACTICES:
- Tag consistently for better recall (project-name, language, domain)
- Use importance scores to prioritize: user preferences (0.9), features (0.8), bugs (0.7)
- Create relationships between related memories for graph navigation
- Update rather than duplicate when knowledge evolves
- Let low-importance memories (<0.3) decay naturally
</memory_rules>
```

## Additional Resources

- **[Claude Code Integration Guide](CLAUDE_CODE_INTEGRATION.md)** - Complete guide to hooks, queue system, and expected behavior
- **[AutoMem Documentation](https://github.com/verygoodplugins/automem)** - Core service documentation
- **[MCP AutoMem Server](https://github.com/verygoodplugins/mcp-automem)** - MCP bridge repository
