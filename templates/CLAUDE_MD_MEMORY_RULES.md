# AutoMem Memory Rules for CLAUDE.md

This template provides AI instructions for automatic memory management with AutoMem. Add this section to your `~/.claude/CLAUDE.md` file to enable intelligent memory storage and recall.

> **For complete integration details**, see [CLAUDE_CODE_INTEGRATION.md](CLAUDE_CODE_INTEGRATION.md) which explains:
> - How the hook system works
> - What files get modified during installation
> - The memory queue and processing pipeline
> - Expected behavior and troubleshooting

> ⚠️ **IMPORTANT:** The default installation is intentionally minimal and quiet (git commits + builds only). Automatic capture hooks beyond these are OPTIONAL and should be enabled only if you explicitly want them. This is an experimental feature actively evolving based on real-world usage. The philosophy is opt-in, not opt-out. Avoid auto-storing content unless the signal is clearly high.

## Quick Installation

```bash
cat templates/CLAUDE_MD_MEMORY_RULES.md >> ~/.claude/CLAUDE.md
```

Or manually copy the `<thinking_mode>` and `<memory_rules>` sections below to `~/.claude/CLAUDE.md`

## Memory Rules Template

Add this to your `~/.claude/CLAUDE.md` file:

```markdown
<memory_rules>
MEMORY MCP USAGE - AUTOMEM INTEGRATION

SESSION INITIALIZATION:
At session start, recall relevant context:
- mcp__memory__recall_memory({ query: "project: [name]", limit: 20, time_query: "last 7 days" })
- mcp__memory__recall_memory({ tags: ["preference", "workflow"], limit: 30 })
- For debugging: recall_memory({ query: "[project] error", tags: ["solution"], time_query: "last 24 hours" })

MCP TOOLS AVAILABLE:
- store_memory: Save with content, type, confidence, tags, importance (0.0-1.0), metadata
- recall_memory: Hybrid search (semantic + keyword + tags + time filters)
- associate_memories: Create relationships (11 types including LEADS_TO, REINFORCES, CONTRADICTS)
- update_memory: Modify existing memories without duplication
- delete_memory: Remove memories by ID
- check_database_health: Monitor AutoMem service status

MEMORY SCHEMA:
- content: Memory text (no [TYPE] prefix needed)
- type: Decision|Pattern|Preference|Style|Habit|Insight|Context (optional, auto-classified if omitted)
- confidence: 0.0-1.0 (default: 0.9 if type provided, auto-computed otherwise)
- importance: 0.9-1.0 (critical), 0.7-0.8 (important), 0.5-0.6 (standard), <0.5 (minor)
- tags: Array for categorization and filtering
- embedding: 768-dim vector (auto-generated by AutoMem if OPENAI_API_KEY set)

STORAGE PATTERNS (opt-in, use when appropriate):

User preferences (importance: 0.9):
  mcp__memory__store_memory({
    content: "User preference: [exact quote]",
    type: "Preference",
    confidence: 0.95,
    tags: ["preference", "workflow"],
    importance: 0.9
  })

Architectural decisions (importance: 0.9):
  mcp__memory__store_memory({
    content: "Decided [choice] because [rationale]",
    type: "Decision",
    confidence: 0.95,
    tags: ["architecture", "project-name"],
    importance: 0.9
  })

Bug fixes (importance: 0.7-0.8):
  mcp__memory__store_memory({
    content: "Fixed [issue] in [project]: [solution]. Root cause: [analysis]",
    type: "Insight",
    confidence: 0.9,
    tags: ["bugfix", "project-name", "solution"],
    importance: 0.8
  })

Feature implementations (importance: 0.7-0.8):
  mcp__memory__store_memory({
    content: "Implemented [feature] using [approach]. Impact: [outcome]",
    type: "Pattern",
    confidence: 0.9,
    tags: ["feature", "project-name", "pattern"],
    importance: 0.7
  })

RECALL PATTERNS:

Hybrid search (semantic + keyword):
  mcp__memory__recall_memory({
    query: "[search terms]",
    tags: ["relevant", "tags"],
    limit: 15,
    time_query: "last 30 days"
  })

Tag-based filtering:
  mcp__memory__recall_memory({
    tags: ["pattern", "react", "hooks"],
    tag_mode: "all",  // or "any" (default)
    limit: 20
  })

Time-constrained search:
  mcp__memory__recall_memory({
    query: "[topic]",
    time_query: "today" | "last week" | "last 7 days"
  })

RELATIONSHIP TYPES:
| Type | Use Case |
|------|----------|
| LEADS_TO | Bug → Solution, Problem → Fix |
| REINFORCES | Supporting evidence, Validation |
| CONTRADICTS | Conflicting approaches, Alternatives |
| EVOLVED_INTO | Knowledge progression, Iterations |
| INVALIDATED_BY | Outdated info → Current approach |
| DERIVED_FROM | Source relationships, Origins |
| RELATES_TO | General connections |
| PREFERS_OVER | User/team preferences |
| EXEMPLIFIES | Pattern examples |
| OCCURRED_BEFORE | Temporal sequence |
| PART_OF | Hierarchical structure |

LIFECYCLE MANAGEMENT:

Update evolving knowledge:
  mcp__memory__update_memory({
    memory_id: "id",
    content: "Updated: [new insight]",
    type: "Insight",
    confidence: 0.95,
    importance: 0.9
  })

Deprecate outdated info:
  mcp__memory__update_memory({
    memory_id: "old_id",
    importance: 0.1,
    metadata: { deprecated: true }
  })
  // Then: associate_memories(old_id, new_id, type="INVALIDATED_BY")

Delete duplicates:
  // First check: recall_memory({ query: "[keywords]", limit: 5 })
  // If found: delete_memory(memory_id)

NEVER STORE:
- Temporary file contents or debug output
- Sensitive credentials or keys
- Large code blocks (store patterns/decisions instead)
- Duplicate memories (check first with recall)
- Type prefixes in content ([DECISION], [BUG-FIX], etc. - use type field instead)

BEST PRACTICES:
- Tag consistently for better recall (project-name, language, domain)
- Use importance scores to prioritize: user preferences (0.9), features (0.8), bugs (0.7)
- Create relationships between related memories for graph navigation
- Update rather than duplicate when knowledge evolves
- Let low-importance memories (<0.3) decay naturally
</memory_rules>
```

## Additional Resources

- **[Claude Code Integration Guide](CLAUDE_CODE_INTEGRATION.md)** - Complete guide to hooks, queue system, and expected behavior
- **[AutoMem Documentation](https://github.com/verygoodplugins/automem)** - Core service documentation
- **[MCP AutoMem Server](https://github.com/verygoodplugins/mcp-automem)** - MCP bridge repository
